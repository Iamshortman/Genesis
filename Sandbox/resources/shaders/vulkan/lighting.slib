struct DirectionalLight
{
    vec3 color;
    float intensity;
	
	vec3 direction;
};

struct PointLight
{
    vec3 color;
    float intensity;

    vec2 attenuation;
	vec3 position;
    float range;
};

struct SpotLight
{
	vec3 color;
    float intensity;

    vec2 attenuation;
	vec3 position;
    float range;
	
    vec3 direction;
    float cutoff;
};

//TODO configure specular_factor;
vec4 CalcLight(vec3 color, float intensity, vec3 direction, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
    float diffuseFactor = dot(normal, -direction);
    
    vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);
    
    if(diffuseFactor > 0.0)
    {
        diffuse_color = vec4(color, 1.0) * intensity * diffuseFactor;
        	
		float specular_strength = 0.5;
        vec3 eye_dir = normalize(eye_pos - world_pos);
        vec3 reflect_dir = normalize(reflect(direction, normal));
        
        float specular_factor = pow(max(dot(eye_dir, reflect_dir), 0.0), 32.0);
		specular_color = vec4(color, 1.0) * specular_strength * specular_factor;
    }
    
    return diffuse_color + specular_color;
}

vec4 CalcPoint(vec3 color, float intensity, vec2 attenuation, vec3 position, float range, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
 vec3 lightDirection = world_pos - position;
    float distance_to_point = length(lightDirection);
    
    if(distance_to_point > range)
        return vec4(0.0, 0.0, 0.0, 0.0);
    
    lightDirection = normalize(lightDirection);
    
    vec4 out_color = CalcLight(color, intensity, lightDirection, normal, world_pos, eye_pos);
    
    float attenuation_value =
                         (attenuation.x * distance_to_point) + //Linear
                         (attenuation.y * (distance_to_point * distance_to_point)) + //Quadratic
                         0.0001; //Stop it from being zero
                         
    return out_color / attenuation_value;
}

vec4 CalcDirectionalLight(DirectionalLight directional_light, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
    return CalcLight(directional_light.color, directional_light.intensity, directional_light.direction, normal, world_pos, eye_pos);
}


vec4 CalcPointLight(PointLight point, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
	return CalcPoint(point.color, point.intensity, point.attenuation, point.position, point.range, normal, world_pos, eye_pos);
}

vec4 CalcSpotLight(SpotLight spot, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
    vec3 light_direction = normalize(world_pos - spot.position);
    float spot_factor = dot(light_direction, spot.direction);
    
    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
    
    if(spot_factor > spot.cutoff)
    {
        color = CalcPoint(spot.color, spot.intensity, spot.attenuation, spot.position, spot.range, normal, world_pos, eye_pos) * (1.0 - (1.0 - spot_factor)/(1.0 - spot.cutoff));
    }
    
    return color;
}

float CalcShadow(sampler2D shadow_map, vec4 light_space_pos)
{
    // perform perspective divide
    vec3 projCoords = ((light_space_pos.xyz / light_space_pos.w) * 0.5) + 0.5;
	float currentDepth = projCoords.z;
	float closestDepth = (texture(shadow_map, projCoords.xy).r * 0.5) + 0.5;
	
	float bias = 0.00004;
	float shadow = currentDepth - bias > closestDepth  ? 0.0 : 1.0;   
    return shadow;
}