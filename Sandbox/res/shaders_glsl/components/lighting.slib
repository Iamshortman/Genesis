struct DirectionalLight
{
    vec3 color;
    float intensity;
	
	vec3 direction;
};

struct PointLight
{
    vec3 color;
    float intensity;

    vec2 attenuation;
	vec3 position;
    float range;
};

struct SpotLight
{
	vec3 color;
    float intensity;

    vec2 attenuation;
	vec3 position;
    float range;
	
    vec3 direction;
    float cutoff;
};

//TODO configure specular_factor;
vec4 CalcLight(vec3 color, float intensity, vec3 direction, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
    float diffuseFactor = dot(normal, -direction);
    
    vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);
    
    if(diffuseFactor > 0.0)
    {
        diffuse_color = vec4(color, 1.0) * intensity * diffuseFactor;
        	
		float specular_strength = 0.5;
        vec3 eye_dir = normalize(eye_pos - world_pos);
        vec3 reflect_dir = normalize(reflect(direction, normal));
        
        float specular_factor = pow(max(dot(eye_dir, reflect_dir), 0.0), 32.0);
		specular_color = vec4(color, 1.0) * specular_strength * specular_factor;
    }
    
    return diffuse_color + specular_color;
}

vec4 CalcPoint(vec3 color, float intensity, vec2 attenuation, vec3 position, float range, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
 vec3 lightDirection = world_pos - position;
    float distance_to_point = length(lightDirection);
    
    if(distance_to_point > range)
        return vec4(0.0, 0.0, 0.0, 0.0);
    
    lightDirection = normalize(lightDirection);
    
    vec4 out_color = CalcLight(color, intensity, lightDirection, normal, world_pos, eye_pos);
    
    float attenuation_value =
                         (attenuation.x * distance_to_point) + //Linear
                         (attenuation.y * (distance_to_point * distance_to_point)) + //Quadratic
                         0.0001; //Stop it from being zero
                         
    return out_color / attenuation_value;
}

vec4 CalcDirectionalLight(DirectionalLight directional_light, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
    return CalcLight(directional_light.color, directional_light.intensity, directional_light.direction, normal, world_pos, eye_pos);
}


vec4 CalcPointLight(PointLight point, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
	return CalcPoint(point.color, point.intensity, point.attenuation, point.position, point.range, normal, world_pos, eye_pos);
}

vec4 CalcSpotLight(SpotLight spot, vec3 normal, vec3 world_pos, vec3 eye_pos)
{
    vec3 light_direction = normalize(world_pos - spot.position);
    float spot_factor = dot(light_direction, spot.direction);
    
    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
    
    if(spot_factor > spot.cutoff)
    {
        color = CalcPoint(spot.color, spot.intensity, spot.attenuation, spot.position, spot.range, normal, world_pos, eye_pos) * (1.0 - (1.0 - spot_factor)/(1.0 - spot.cutoff));
    }
    
    return color;
}

float CalcShadow(sampler2D shadow_map, vec4 light_space_pos)
{
    // perform perspective divide
    vec3 proj_coords = ((light_space_pos.xyz / light_space_pos.w) * 0.5) + 0.5;
	float current_depth = proj_coords.z;
	float closest_depth = (texture(shadow_map, proj_coords.xy).r * 0.5) + 0.5;
	
	float bias = 0.00004;
	float shadow = current_depth - bias > closest_depth  ? 0.0 : 1.0;   
    return shadow;
}

vec2 ParallaxMapping(sampler2D depth_map, vec2 tex_coords, vec3 view_dir, float height_scale)
{
    float height = texture(depth_map, tex_coords).r;    
    vec2 p = view_dir.xy * (height * height_scale) / view_dir.z;
    return tex_coords - p; 
}

vec2 ParallaxOcclusionMapping(sampler2D depth_map, vec2 tex_coords, vec3 view_dir, float height_scale)
{ 
	if(height_scale == 0.0)
	{
		return tex_coords;
	}

    // number of depth layers
    const float min_layers = 8;
    const float max_layers = 32;
    float num_layers = mix(max_layers, min_layers, abs(dot(vec3(0.0, 0.0, 1.0), view_dir)));
	
    // calculate the size of each layer
    float layer_depth = 1.0 / num_layers;
    // depth of current layer
    float current_layer_depth = 0.0;
	
    // the amount to shift the texture coordinates per layer (from vector P)
    vec2 P = view_dir.xy / view_dir.z * height_scale; 
    vec2 delta_tex_coords = P / num_layers;
  
    // get initial values
    vec2  current_tex_coords = tex_coords;
    float current_depth_map_value = (1.0 - texture(depth_map, current_tex_coords).r);
      
    while(current_layer_depth < current_depth_map_value)
    {
        // shift texture coordinates along direction of P
        current_tex_coords -= delta_tex_coords;
        // get depth_map value at current texture coordinates
        current_depth_map_value = (1.0 - texture(depth_map, current_tex_coords).r);  
        // get depth of next layer
        current_layer_depth += layer_depth;  
    }
    
    // get texture coordinates before collision (reverse operations)
    vec2 prev_tex_coords = current_tex_coords + delta_tex_coords;

    // get depth after and before collision for linear interpolation
    float after_depth  = current_depth_map_value - current_layer_depth;
    float before_depth = (1.0 - texture(depth_map, prev_tex_coords).r) - current_layer_depth + layer_depth;
 
    // interpolation of texture coordinates
    float weight = after_depth / (after_depth - before_depth);
    vec2 final_tex_coords = prev_tex_coords * weight + current_tex_coords * (1.0 - weight);

    return final_tex_coords;
}
